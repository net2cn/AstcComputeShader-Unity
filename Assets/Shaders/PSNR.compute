// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Diff
#pragma kernel Reduce

Texture2D OriginalTexture;
Texture2D CompareTexture;

int InTexelWidth;
int InTexelHeight;

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> OutTexture;

// MSE
[numthreads(8,8,1)]
void Diff(uint3 tid : SV_DispatchThreadID, uint index : SV_GroupIndex)
{
    float4 diff = OriginalTexture[tid.xy] - CompareTexture[tid.xy];
    OutTexture[tid.xy] = diff * diff;
}


// MSE Reduce
#define THREAD_NUM 512
#define REDUCTION_FUNC(src, id_0, id_1)  (src[id_0] + src[id_1])

bool FirstStep;
uint ThreadCount;

RWStructuredBuffer<float4> OutBuffer;
groupshared float4 SharedMem[THREAD_NUM];

[numthreads(THREAD_NUM, 1, 1)]
void Reduce(uint tid : SV_DispatchThreadID, uint gid: SV_GroupID, uint index: SV_GroupIndex)
{
    if (FirstStep)
    {
        uint2 texPosA = uint2((tid * 2) % InTexelWidth, (tid * 2) / InTexelHeight);
        uint2 texPosB = uint2((tid * 2 + 1) % InTexelWidth, (tid * 2 + 1) / InTexelHeight);
        SharedMem[index] = REDUCTION_FUNC(OutTexture, texPosA, texPosB);
    }
    else
    {
        SharedMem[index] = REDUCTION_FUNC(OutBuffer, tid * 2, tid * 2 + 1);
    }
    GroupMemoryBarrierWithGroupSync();
    
    [unroll(THREAD_NUM)]
    for (uint s = ThreadCount / 2; s > 0; s >>= 1)
    {
        if (index < s)
        {
            SharedMem[index] = REDUCTION_FUNC(SharedMem, index, index + s);
        }
        
        GroupMemoryBarrierWithGroupSync();
    }
    
    if (index < 1)
    {
        OutBuffer[gid] = SharedMem[0];
    }
}